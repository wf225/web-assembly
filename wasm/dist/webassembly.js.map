{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "src"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function(){function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s}return e})()",
    "\"use strict\";\n\nif (typeof window !== \"undefined\" && window)\n    window.webassembly = exports;\n\n// Common aliases\nvar getOwnPropertyNames = Object.getOwnPropertyNames;\n\n/**\n * Describes a module instance as returned by {@link load}.\n * @interface IModule\n * @property {Object.<string,*>} exports Exports\n * @property {Object.<string,*>} imports Imports\n * @property {IMemory} memory Memory\n * @property {Object.<string,*>} env Environment\n */\n\n/**\n * Describes a module memory instance.\n * @interface IMemory\n * @property {ArrayBuffer} buffer Underlying buffer\n * @property {number} initial=1 Specified initial amount of memory in 64k pages\n * @property {number} [maximum] If specified, maximum amount of memory in 64k pages\n * @property {Uint8Array} U8 Byte-level view\n * @property {Uint32Array} U32 Aligned unsigned 32-bit integer view\n * @property {Int32Array} S32 Aligned signed 32-bit integer view\n * @property {Float32Array} F32 Aligned 32-bit float view\n * @property {Float64Array} F64 Aligned 64-bit double view\n * @property {GetInt} getInt Reads a 32-bit signed integer starting at the specified memory offset (aligned to 4 bytes)\n * @property {GetUint} getUint Reads a 32-bit unsigned integer starting at the specified memory offset (aligned to 4 bytes)\n * @property {GetFloat} getFloat Reads a 32-bit float starting at the specified memory offset (aligned to 4 bytes)\n * @property {GetDouble} getDouble Reads a 64-bit double starting at the specified memory offset (aligned to 8 bytes)\n * @property {GetString} getString Reads the (zero-terminated, exclusive) string starting at the specified memory offset (aligned to 4 bytes)\n */\n\n/**\n * Loads a WebAssembly.\n * @param {string} file File name\n * @param {LoadOptions} [options] Options\n * @returns {Promise.<IModule>} Promise resolving to the instantiated module\n */\nfunction load(file, options) {\n\n    /**\n     * Options as used by {@link load}.\n     * @interface LoadOptions\n     * @property {number} [initialMemory=1] Initial memory in pages of 64k\n     * @property {number} [maximumMemory] Maximum memory in pages of 64k\n     * @property {Object.<string,*>} [imports] Imports\n     */\n\n    options || (options = {});\n\n    var imports = options.imports || {};\n\n    // Initialize memory\n\n    var memory = imports.memory;\n    if (!memory) {\n        var opts = { initial: options.initialMemory || 1 };\n        if (options.maximumMemory)\n            opts.maximum = options.maximumMemory;\n        memory = new WebAssembly.Memory(opts);\n        memory.initial = options.initialMemory || 1;\n        memory.maximum = options.maximumMemory;\n    }\n\n    var table = imports.table;\n    if (!table)\n        table = new WebAssembly.Table({ initial: 0, element: \"anyfunc\" });\n\n    function grow() {\n        var buf = memory.buffer;\n        memory.U8  = new Uint8Array  (buf);\n        memory.S32 = new Int32Array  (buf);\n        memory.U32 = new Uint32Array (buf);\n        memory.F32 = new Float32Array(buf);\n        memory.F64 = new Float64Array(buf);\n    }\n\n    grow();\n\n    // Add utilty to memory\n\n    /**\n     * Reads a 32-bit signed integer starting at the specified memory offset.\n     * @typedef GetInt\n     * @function\n     * @param {number} ptr Memory offset\n     * @returns {number} Signed 32-bit integer value\n     */\n    function getInt(ptr) {\n        return memory.S32[ptr >> 2];\n    }\n\n    memory.getInt = getInt;\n\n    /**\n     * Reads a 32-bit unsigned integer starting at the specified memory offset.\n     * @typedef GetUint\n     * @function\n     * @param {number} ptr Memory offset\n     * @returns {number} Unsigned 32-bit integer value\n     */\n    function getUint(ptr) {\n        return memory.U32[ptr >> 2];\n    }\n\n    memory.getUint = getUint;\n\n    /**\n     * Reads a 32-bit float starting at the specified memory offset.\n     * @typedef GetFloat\n     * @function\n     * @param {number} ptr Memory offset\n     * @returns {number} 32-bit float value\n     */\n    function getFloat(ptr) {\n        return memory.F32[ptr >> 2];\n    }\n\n    memory.getFloat = getFloat;\n\n    /**\n     * Reads a 64-bit double starting at the specified memory offset.\n     * @typedef GetDouble\n     * @function\n     * @param {number} ptr Memory offset\n     * @returns {number} 64-bit float value\n     */\n    function getDouble(ptr) {\n        return memory.F64[ptr >> 3];\n    }\n\n    memory.getDouble = getDouble;\n\n    /**\n     * Reads a (zero-terminated, exclusive) string starting at the specified memory offset.\n     * @typedef GetString\n     * @function\n     * @param {number} ptr Memory offset\n     * @returns {string} String value\n     */\n    function getString(ptr) {\n        var start = (ptr >>>= 0);\n        while (memory.U8[ptr++]);\n        getString.bytes = ptr - start;\n        return String.fromCharCode.apply(null, memory.U8.subarray(start, ptr - 1));\n    }\n\n    memory.getString = getString;\n\n    // Initialize environment\n\n    var env = {};\n\n    env.memoryBase = imports.memoryBase || 0;\n    env.memory = memory;\n    env.tableBase = imports.tableBase || 0;\n    env.table = table;\n\n    // Add console to environment\n\n    function sprintf(ptr, base) {\n        var s = getString(ptr);\n        return base\n            ? s.replace(/%([dfisu]|lf)/g, ($0, $1) => {\n                var val;\n                return base +=\n                    $1 === \"u\"  ? (val = getUint(base), 4)\n                  : $1 === \"f\"  ? (val = getFloat(base), 4)\n                  : $1 === \"s\"  ? (val = getString(getUint(base)), 4)\n                  : $1 === \"lf\" ? (val = getDouble(base), 8)\n                  :               (val = getInt(base), 4)\n                  , val;\n            })\n            : s;\n    }\n\n    getOwnPropertyNames(console).forEach(key => {\n        if (typeof console[key] === \"function\") // eslint-disable-line no-console\n            env[\"console_\" + key] = (ptr, base) => {\n                console[key](sprintf(ptr, base)); // eslint-disable-line no-console\n            };\n    });\n\n    // Add Math to environment\n\n    getOwnPropertyNames(Math).forEach(key => {\n        if (typeof Math[key] === \"function\")\n            env[\"Math_\" + key] = Math[key];\n    });\n\n    // Add imports to environment\n\n    Object.keys(imports).forEach(key => env[key] = imports[key]);\n\n    // Add default exit listeners if not explicitly imported\n\n    if (!env._abort)\n        env._abort = errno => { throw Error(\"abnormal abort in \" + file + \": \" + errno); };\n    if (!env._exit)\n        env._exit = code => { if (code) throw Error(\"abnormal exit in \" + file + \": \" + code); }\n\n    // Finally, fetch the assembly and instantiate it\n\n    env._grow = grow;\n\n    return (typeof fetch === \"function\" && fetch || fetch_node)(file)\n        .then(result => result.arrayBuffer())\n        .then(buffer => WebAssembly.instantiate(buffer, { env: env }))\n        .then(module => {\n            var instance = module.instance;\n            instance.imports = imports;\n            instance.memory = memory;\n            instance.env = env;\n            return instance;\n        });\n}\n\nexports.load = load;\n\n// Internal fetch API polyfill for node that doesn't trigger webpack\nvar fs;\nfunction fetch_node(file) {\n    return new Promise((resolve, reject) => (fs || (fs = eval(\"equire\".replace(/^/, \"r\"))(\"fs\"))).readFile(file, (err, data) => err ? reject(err) : resolve({ arrayBuffer: () => data })));\n}\n"
  ]
}